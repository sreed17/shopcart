{"version":3,"file":"index.mjs","sources":["../src/ShoppingCartItem.ts","../src/ShoppingCart.ts","../src/Persistance.ts","../src/index.ts","../src/ShoppingCartContext.ts","../src/ShoppingCartProvider.tsx","../src/useShoppingCartContext.ts"],"sourcesContent":["/**\n * @file ShoppingCartItem.ts\n * @description Represents a single item in a shopping cart, managing its details such as product information, quantity, unit price, and discounts.\n */\n\nimport { ICartParameters } from \"./ShoppingCart\";\nimport { IOnChangeCallback } from \"./common_types\";\n\n/**\n * Represents the required parameters for creating a shopping cart item.\n */\nexport type IRequiredParameters<ProductType> = {\n\t/**\n\t * Index (position) of the item in the shopping cart.\n\t */\n\tindex: number;\n\n\t/**\n\t * The unique identifier for the product. Used for hashing\n\t */\n\tid: string;\n\t/**\n\t * The product details.\n\t */\n\tproduct: ProductType;\n\t/**\n\t * The price per unit of the product.\n\t */\n\tunit_price: number;\n};\n\n/**\n * Represents the optional parameters for creating a shopping cart item.\n */\nexport type IOptionalParameters = {\n\t/**\n\t * The quantity of the product.\n\t * Default: 1\n\t */\n\tquantity?: number;\n\t/**\n\t * The discount applied to each unit of the product.\n\t * Default: 0\n\t */\n\tunit_discount?: number;\n\t/**\n\t * The discount applied to the total price of the product.\n\t * Default: 0\n\t */\n\ttotal_discount?: number;\n};\n\n/**\n * Represents the parameters for creating a shopping cart item.\n */\nexport type ICartItemParameters<ProductType> =\n\tIRequiredParameters<ProductType> & IOptionalParameters;\n\nexport interface ICartItemJSON<ProductType> {\n\tindex: number;\n\tid: string;\n\tproduct: ProductType;\n\tunit_price: number;\n\tquantity: number;\n\tunit_discount: number;\n\ttotal_discount: number;\n\taggregate_price: number;\n}\n\n/**\n * Represents a single item in the shopping cart.\n * Manages the item's details such as product, quantity, unit price, and discounts.\n */\nexport class ShoppingCartItem<ProductType extends object> {\n\tprivate _index: number;\n\tprivate _prev_index: number | null = null;\n\tprivate _id: string;\n\tprivate _product: ProductType;\n\tprivate _unit_price: number;\n\tprivate _quantity: number;\n\tprivate _aggregate_price: number = 0;\n\tprivate _unit_discount: number;\n\tprivate _total_discount: number;\n\n\tprivate onChangeCallback:\n\t\t| IOnChangeCallback<ShoppingCartItem<ProductType>>\n\t\t| undefined;\n\n\tprivate onChangeHandler() {\n\t\tif (\n\t\t\tthis.onChangeCallback &&\n\t\t\ttypeof this.onChangeCallback === \"function\"\n\t\t) {\n\t\t\tthis.onChangeCallback(this);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the parameters used to create the shopping cart item are valid.\n\t * @returns A boolean indicating whether the parameters are valid.\n\t */\n\tprivate isParametersValid(): boolean {\n\t\treturn (\n\t\t\tthis._unit_price >= 0 &&\n\t\t\tthis._quantity >= 0 &&\n\t\t\tthis._unit_discount >= 0 &&\n\t\t\tthis._total_discount >= 0\n\t\t);\n\t}\n\n\t/**\n\t * Updates the total price of the item based on the current parameters.\n\t */\n\tprivate updateTotalPrice(): void {\n\t\tif (!this.isParametersValid()) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error updating the total price for the product stack: \" +\n\t\t\t\t\t\"check the unit_price, quantity, unit_discount, and total_discount parameters \" +\n\t\t\t\t\t\"and ensure they are non-negative values.\",\n\t\t\t);\n\t\t}\n\n\t\t// Calculate the total price after applying discounts\n\t\tlet aggregate_price =\n\t\t\tthis._quantity * (this._unit_price - this._unit_discount);\n\t\taggregate_price -= aggregate_price * this._total_discount;\n\n\t\t// Update the total price for the item\n\t\tthis._aggregate_price = aggregate_price;\n\t}\n\n\tstatic parse<ProductType extends object>(\n\t\tstr: string,\n\t\tonChange?: IOnChangeCallback<ShoppingCartItem<ProductType>>,\n\t): ShoppingCartItem<ProductType> {\n\t\tconst obj = JSON.parse(str);\n\t\tif (!isShoppingCartItemJSON(obj)) {\n\t\t\tthrow new Error(\"Error parsing the ShoppingCartItem: invalid format.\");\n\t\t}\n\n\t\tconst params: ICartItemParameters<ProductType> = {\n\t\t\tindex: obj.index,\n\t\t\tid: obj.id,\n\t\t\tproduct: obj.product as ProductType,\n\t\t\tunit_price: obj.unit_price,\n\t\t\tquantity: obj.quantity,\n\t\t\ttotal_discount: obj.total_discount,\n\t\t\tunit_discount: obj.unit_discount,\n\t\t};\n\t\treturn new ShoppingCartItem<ProductType>({ ...params }, onChange);\n\t}\n\n\t/**\n\t * Returns the ShoppingCartItem as an object consisting of all its public properties.\n\t * @returns An object representing the ShoppingCartItem with its public properties.\n\t */\n\tvalueOf(): ICartItemJSON<ProductType> {\n\t\treturn {\n\t\t\tindex: this._index,\n\t\t\tid: this._id,\n\t\t\tproduct: { ...this._product },\n\t\t\tunit_price: this.unit_price,\n\t\t\tquantity: this._quantity,\n\t\t\tunit_discount: this.unit_discount,\n\t\t\ttotal_discount: this.total_discount,\n\t\t\taggregate_price: this._aggregate_price,\n\t\t};\n\t}\n\n\t/**\n\t * Returns the JSON representation, the ShoppingCartItem as an object consisting of all its public properties.\n\t * @returns An object representing the ShoppingCartItem with its public properties.\n\t */\n\ttoJSON() {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Returns the serialized version of the instance as a JSON string.\n\t * @returns A JSON string representing the serialized version of the instance.\n\t */\n\ttoString(): string {\n\t\treturn JSON.stringify(this);\n\t}\n\n\t/**\n\t * Clones the current shopping cart item.\n\t * @returns A new instance of ShoppingClassItem with the same parameters as the current item.\n\t */\n\tclone(): ShoppingCartItem<ProductType> {\n\t\treturn new ShoppingCartItem(\n\t\t\t{\n\t\t\t\tindex: this._index,\n\t\t\t\tid: this._id,\n\t\t\t\tproduct: this._product,\n\t\t\t\tunit_price: this._unit_price,\n\t\t\t\tquantity: this._quantity,\n\t\t\t\tunit_discount: this._unit_discount,\n\t\t\t\ttotal_discount: this._total_discount,\n\t\t\t},\n\t\t\tthis.onChangeCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Increments the quantity of the item by the specified amount.\n\t * @param increment_size The amount by which to increment the quantity.\n\t */\n\tincrementQuantity(increment_size: number = 1): void {\n\t\tif (increment_size <= 0) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error updating the shopping cart item quantity: increment_size must be a positive non-zero number\",\n\t\t\t);\n\t\t}\n\t\tthis._quantity += increment_size;\n\t\tthis.updateTotalPrice();\n\n\t\t// trigger change callback\n\t\tthis.onChangeHandler();\n\t}\n\n\t/**\n\t * Decrements the quantity of the item by the specified amount.\n\t * @param decrement_size The amount by which to decrement the quantity.\n\t */\n\tdecrementQuantity(decrement_size: number = 1): void {\n\t\tif (decrement_size <= 0) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error updating the shopping cart item quantity: decrement_size must be a positive non-zero number\",\n\t\t\t);\n\t\t}\n\t\tconst new_quantity = this._quantity - decrement_size;\n\t\tthis._quantity = new_quantity < 0 ? 0 : new_quantity;\n\t\tthis.updateTotalPrice();\n\n\t\t// trigger change callback\n\t\tthis.onChangeHandler();\n\t}\n\n\t/**\n\t * Sets the total discount applied to the item.\n\t * @param total_discount The total discount to apply.\n\t */\n\tsetTotalDiscount(total_discount: number): void {\n\t\tthis._total_discount = total_discount;\n\t\tthis.updateTotalPrice();\n\n\t\t// trigger change callback\n\t\tthis.onChangeHandler();\n\t}\n\n\t/**\n\t * Change the index(position) of the item in the shopping cart.\n\t * @param new_index The new index of the item in the shopping cart.\n\t */\n\tsetIndex(new_index: number) {\n\t\tif (this.prev_index !== null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error changing the index of cart item: a pending move exists\",\n\t\t\t);\n\t\t}\n\n\t\tthis._prev_index = this.index;\n\t\tthis._index = new_index;\n\t}\n\n\tclearPrevIndex() {\n\t\tif (this.prev_index == null) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error trying to clear prev index when prev index is null\",\n\t\t\t);\n\t\t}\n\t\tthis._prev_index = null;\n\t}\n\n\t// =================\n\t// public properties\n\t// =================\n\n\tget index(): number {\n\t\treturn this._index;\n\t}\n\n\tget prev_index(): number | null {\n\t\treturn this._prev_index;\n\t}\n\n\tget id(): string {\n\t\treturn this._id;\n\t}\n\n\tget product(): ProductType {\n\t\treturn this._product;\n\t}\n\n\tget unit_price(): number {\n\t\treturn this._unit_price;\n\t}\n\n\tget quantity(): number {\n\t\treturn this._quantity;\n\t}\n\n\tget unit_discount(): number {\n\t\treturn this._unit_discount;\n\t}\n\n\tget total_discount(): number {\n\t\treturn this._total_discount;\n\t}\n\n\tget aggregate_price(): number {\n\t\treturn this._aggregate_price;\n\t}\n\n\t// ============\n\t// Constructor\n\t// ============\n\n\t/**\n\t * Constructs a new instance of ShoppingClassItem.\n\t * @param args The parameters used to initialize the shopping cart item.\n\t */\n\tconstructor(\n\t\targs: ICartItemParameters<ProductType>,\n\t\tonChange?: IOnChangeCallback<ShoppingCartItem<ProductType>>,\n\t) {\n\t\t// Assign default values to optional parameters if not provided\n\t\tconst {\n\t\t\tindex,\n\t\t\tid,\n\t\t\tproduct,\n\t\t\tunit_price,\n\t\t\tquantity = 1,\n\t\t\tunit_discount = 0,\n\t\t\ttotal_discount = 0,\n\t\t}: ICartItemParameters<ProductType> = args;\n\n\t\t// Assign parameters to instance variables\n\t\tthis._index = index;\n\t\tthis._id = id;\n\t\tthis._product = product;\n\t\tthis._quantity = quantity;\n\t\tthis._unit_price = unit_price;\n\t\tthis._unit_discount = unit_discount;\n\t\tthis._total_discount = total_discount;\n\n\t\tthis.onChangeCallback = onChange;\n\n\t\t// Update the total price based on the provided parameters\n\t\tthis.updateTotalPrice();\n\t}\n}\n\n/**\n * Default parameters for creating a shopping cart item.\n */\nconst defaultParameters: IOptionalParameters = {\n\tunit_discount: 0,\n\ttotal_discount: 0,\n\tquantity: 1,\n};\n\n/**\n * Check whether a given argument is an instance of ShoppingCartItem.\n * @param arg The argument to check.\n * @returns A boolean indicating whether the argument is an instance of ShoppingCartItem.\n */\nexport function isShoppingCartItem<T extends object>(\n\targ: unknown,\n): arg is ShoppingCartItem<T> {\n\tif (!arg || typeof arg !== \"object\") {\n\t\treturn false;\n\t}\n\treturn arg instanceof ShoppingCartItem;\n}\n\nexport function isShoppingCartItemJSON<T extends object>(\n\targ: unknown,\n): arg is ICartItemJSON<T> {\n\tif (!arg || typeof arg !== \"object\") {\n\t\treturn false;\n\t}\n\tconst props = [\n\t\t\"index\",\n\t\t\"id\",\n\t\t\"product\",\n\t\t\"unit_price\",\n\t\t\"quantity\",\n\t\t\"unit_discount\",\n\t\t\"total_discount\",\n\t\t\"aggregate_price\",\n\t];\n\n\tfor (let prop of props) {\n\t\tif (!(prop in arg)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (prop !== \"product\" && prop !== \"id\") {\n\t\t\tconst n_value = Number(arg[prop as keyof typeof arg]);\n\t\t\tif (Number.isNaN(n_value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (prop === \"id\") {\n\t\t\tconst n_value = Number(arg[prop as keyof typeof arg]);\n\t\t\tif (typeof n_value !== \"string\") {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n","/**\n * @file ShoppingCart.ts\n * @description Represent the shopping cart\n */\n\nimport {\n\tICartItemJSON,\n\tICartItemParameters,\n\tShoppingCartItem,\n\tisShoppingCartItem,\n} from \"./ShoppingCartItem\";\nimport { IOnChangeCallback } from \"./common_types\";\n\n/**\n * Represents the parameters required to create a shopping cart item.\n */\nexport type ICartItemCreateParameters<T> = Omit<\n\tICartItemParameters<T>,\n\t\"index\"\n>;\n\n/**\n * Represents the parameters required to initialize a shopping cart.\n */\nexport type ICartParameters<ProductType extends object> = {\n\t/**\n\t * The initial items in the shopping cart.\n\t */\n\titems?: ShoppingCartItem<ProductType>[];\n\t/**\n\t * The callback function to be called when the shopping cart changes.\n\t */\n\tonChange?: IOnChangeCallback<\n\t\tShoppingCart<ProductType> | ShoppingCartItem<ProductType>\n\t>;\n\t/**\n\t * The callback function to be called when the checkout process is triggered.\n\t */\n\tonCheckout?: IOnChangeCallback<ShoppingCart<ProductType>>;\n};\n\n/**\n * Represents a shopping cart that can hold items of a specific product type.\n * @typeparam T The type of product items that the shopping cart can hold.\n */\nexport default class ShoppingCart<ProductType extends object> {\n\t// Array to hold the shopping card items. This can be considered an independent state.\n\tprivate items: ShoppingCartItem<ProductType>[];\n\t// Hashmap to store item indices based on their IDs for quick retrieval\n\tprivate hmap: Record<string, number> = {};\n\t// The total cost of all items in the shopping cart before taxes and shipping charges are applied.\n\tprivate _sub_total: number = 0;\n\t// Callback function to be called when the shopping cart changes\n\tprivate onChange: ICartParameters<ProductType>[\"onChange\"];\n\t// Callback function to be called when the checkout process is triggered\n\tprivate onCheckout: ICartParameters<ProductType>[\"onCheckout\"];\n\n\t/**\n\t * Update the dependent states of the shopping cart.\n\t * This includes updating the hashmap and calculating the subtotal.\n\t */\n\tprivate updateDependentStates() {\n\t\tconst hmap: Record<string, number> = {};\n\n\t\tlet sum = 0;\n\n\t\tfor (let i = 0; i < this.items.length; i++) {\n\t\t\tthis.items[i].setIndex(i);\n\t\t\tconst id = this.items[i].id;\n\t\t\thmap[id] = i;\n\t\t\tthis.items[i].clearPrevIndex();\n\t\t\tsum += this.items[i].aggregate_price;\n\t\t}\n\n\t\tthis._sub_total = sum;\n\t\tthis.hmap = hmap;\n\t}\n\n\t/**\n\t * Emits the onChange callback if provided.\n\t */\n\tprivate emitOnChange() {\n\t\tif (this.onChange) {\n\t\t\tthis.onChange(this);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new item to the shopping cart.\n\t * @param arg The parameters to create the new item.\n\t */\n\tprivate addNewItem(\n\t\targ: ICartItemParameters<ProductType> | ShoppingCartItem<ProductType>,\n\t) {\n\t\tlet item: ShoppingCartItem<ProductType>;\n\t\tif (isShoppingCartItem<ProductType>(arg)) {\n\t\t\titem = arg;\n\t\t} else {\n\t\t\titem = new ShoppingCartItem(arg, this.onChange);\n\t\t}\n\t\tthis.items.push(item);\n\t\tthis.hmap[arg.id] = arg.index;\n\t\tthis._sub_total += item.aggregate_price;\n\n\t\t// Trigger change\n\t\tthis.emitOnChange();\n\t}\n\n\t/**\n\t * Removes an item from the shopping cart by its index.\n\t * @param index The index of the item to remove.\n\t */\n\tprivate removeItemByIndex(index: number) {\n\t\t// Check if the index is within the allowed range\n\t\tif (index < 0 || index >= this.items.length) {\n\t\t\tthrow new Error(\n\t\t\t\t`Error removing cart item by index: index out of bound. index[${index}]`,\n\t\t\t);\n\t\t}\n\n\t\tconst id = this.items[index].id;\n\t\tthis.items.splice(index, 1);\n\n\t\tthis.updateDependentStates();\n\n\t\t// Trigger change\n\t\tthis.emitOnChange();\n\t}\n\n\t/**\n\t * Removes an item from the shopping cart by its ID.\n\t * @param id The ID of the item to remove.\n\t */\n\tprivate removeItemById(id: string) {\n\t\t// Check if the index is within the allowed range\n\t\tif (!(id in this.hmap)) {\n\t\t\tthrow new Error(\n\t\t\t\t`Error removing cart item by id: id not found. id[${id}]`,\n\t\t\t);\n\t\t}\n\n\t\tconst index = this.hmap[id];\n\t\tthis.items.splice(index, 1);\n\n\t\tthis.updateDependentStates();\n\n\t\t// Trigger change\n\t\tthis.emitOnChange();\n\t}\n\n\t/**\n\t * Move the item identified by the identifier to be moved to a new index within the shopping cart.\n\t * @param identifier Either the index of the item or its ID.\n\t * @param new_index  Index to which the item is to be moved.\n\t */\n\tmoveItem(identifier: number | string, new_index: number) {\n\t\tconst index =\n\t\t\ttypeof identifier === \"number\" ? identifier : this.hmap[identifier];\n\n\t\tif (typeof index !== \"number\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error repositioning cart item: identifier cant be resolved, or not found. Check the identifier <index | id>\",\n\t\t\t);\n\t\t}\n\n\t\tif (new_index < 0 || new_index >= this.items.length) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error repositioning cart item: new_index is out of bound.\",\n\t\t\t);\n\t\t}\n\n\t\tconst removed_item = this.items.splice(index, 1);\n\t\tthis.items.splice(new_index, 0, ...removed_item);\n\n\t\t// Reset the prev_index to prevent error during dependent state update.\n\t\t// This acts as a minor lock for manually setting the index from the cart object.\n\t\t// If a user tries to manually set the index from a cart object-\n\t\t// then it must be followed by a move operation to remove the lock.\n\t\tif (this.items[new_index].prev_index !== null) {\n\t\t\tthis.items[new_index].clearPrevIndex();\n\t\t}\n\n\t\tthis.updateDependentStates();\n\n\t\t// Trigger change\n\t\tthis.emitOnChange();\n\t}\n\n\t/**\n\t * Return the number of items in the the cart.\n\t */\n\tget item_count() {\n\t\treturn this.items.length;\n\t}\n\n\t/**\n\t * Return the subtotal of the items in the cart.\n\t */\n\tget sub_total() {\n\t\treturn this._sub_total;\n\t}\n\n\t/**\n\t * Retrieves a ShoppingCartItem from the shopping cart based on the specified key, which can be either a string (ID) or a number (index).\n\t * @param key The key (ID or index) used to retrieve the ShoppingCartItem.\n\t * @returns The ShoppingCartItem corresponding to the specified key.\n\t * @throws Error if the key is not found or if the index is out of bounds.\n\t */\n\tgetCartItem(key: string | number): ShoppingCartItem<ProductType> {\n\t\tswitch (typeof key) {\n\t\t\tcase \"string\": {\n\t\t\t\tif (key in this.hmap) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Error getting the cart item by id: id not found. id[${key}]`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn this.items[this.hmap[key]];\n\t\t\t}\n\t\t\tcase \"number\": {\n\t\t\t\tif (key < 0 || key >= this.items.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Error getting the cart item by index: index out of bound. index[${key}]`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn this.items[key];\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Returns an iterator for iterating over all items in the shopping cart.\n\t * @returns An iterator that yields each ShoppingCartItem in the shopping cart.\n\t */\n\t*[Symbol.iterator]() {\n\t\tfor (const item of this.items) {\n\t\t\tyield item;\n\t\t}\n\t}\n\n\t/**\n\t * Parse a possibly serialized ShoppingCart to ShoppingCartItems array\n\t * @param str - A string which possible be serialized ShoppingCart\n\t */\n\tstatic parse<ProductType extends object>(\n\t\tstr: string,\n\t\tonChange?: IOnChangeCallback<ShoppingCartItem<ProductType>>,\n\t): ShoppingCartItem<ProductType>[] {\n\t\tlet s = str.trim();\n\t\ts = s.replace(/(^\\[|\\]$)/g, \"\");\n\t\tconst item_candidates = s.split(\",\");\n\t\tconst result: ShoppingCartItem<ProductType>[] = [];\n\n\t\tfor (const item_candidate of item_candidates) {\n\t\t\tresult.push(ShoppingCartItem.parse(item_candidate, onChange));\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the value of the shopping cart as an array of objects, each representing a ShoppingCartItem.\n\t * @returns An array of objects representing each ShoppingCartItem in the shopping cart.\n\t */\n\tvalueOf() {\n\t\treturn this.items.map((item) => item.valueOf());\n\t}\n\n\t/**\n\t * Returns the corresponding JSON object of the shopping cart.\n\t * @returns An array of objects representing each ShoppingCartItem in the shopping cart.\n\t */\n\ttoJSON() {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Returns a JSON string representing the value of the shopping cart.\n\t * @returns A JSON string representing the value of the shopping cart.\n\t */\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\t/**\n\t * Creates and returns a deep copy of the shopping cart.\n\t * @returns A new instance of ShoppingCart with identical items, onChange, and onCheckout properties.\n\t */\n\tclone() {\n\t\treturn new ShoppingCart<ProductType>({\n\t\t\titems: this.items,\n\t\t\tonChange: this.onChange,\n\t\t\tonCheckout: this.onCheckout,\n\t\t});\n\t}\n\n\t/**\n\t * Maps each item in the shopping cart to another value using a mapping function.\n\t * @param fn A mapping function that transforms each item's JSON representation.\n\t * @returns An array of transformed values.\n\t */\n\tmap(fn: (value: ICartItemJSON<ProductType>, index: number) => unknown) {\n\t\treturn this.items.map((item, i) => {\n\t\t\treturn fn(item.valueOf(), i);\n\t\t});\n\t}\n\n\t/**\n\t * Adds a new item to the shopping cart or updates the quantity of an existing item if the ID matches.\n\t * @param arg The parameters for the new item to add or update.\n\t */\n\taddItem(arg: ICartItemCreateParameters<ProductType>) {\n\t\tconst id = arg.id;\n\t\tconst item_already_exists = id in this.hmap;\n\n\t\tconst params: ICartItemParameters<ProductType> = {\n\t\t\t...arg,\n\t\t\tindex: this.items.length,\n\t\t};\n\n\t\t// If its a new item (id is not in hmap) then push the new item\n\t\tif (!item_already_exists) {\n\t\t\treturn this.addNewItem(params);\n\t\t}\n\n\t\t// If the items already exists then update the quantity\n\t\tthis.items[this.hmap[id]].incrementQuantity(arg.quantity);\n\t}\n\n\t/**\n\t * Removes an item from the shopping cart based on the specified key, which can be either a string (ID) or a number (index).\n\t * @param arg The key (ID or index) used to identify the item to remove.\n\t */\n\tremoveItem(arg: number | string, quantity?: number) {\n\t\tif (typeof quantity === \"number\" && quantity > 0) {\n\t\t\tconst item = this.getCartItem(arg);\n\n\t\t\tconst old_quantity = item.quantity;\n\t\t\tconst new_quantity = old_quantity - quantity;\n\t\t\tif (new_quantity <= 0) {\n\t\t\t\tthis.removeItemByIndex(item.index);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\titem.decrementQuantity(quantity);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (typeof arg) {\n\t\t\tcase \"string\": {\n\t\t\t\treturn this.removeItemById(arg);\n\t\t\t}\n\t\t\tcase \"number\": {\n\t\t\t\treturn this.removeItemByIndex(arg);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Filters the items in the shopping cart based on the provided function.\n\t * @param fn A function used to filter the items in the shopping cart.\n\t */\n\tfilter(fn: (cart_item: ShoppingCartItem<ProductType>) => boolean) {\n\t\tthis.items.filter(fn);\n\t\tthis.updateDependentStates();\n\n\t\t// Trigger change\n\t\tthis.emitOnChange();\n\t}\n\n\t/**\n\t * Sorts the items in the shopping cart based on the provided comparison function.\n\t * @param fn A function used to compare two items in the shopping cart for sorting.\n\t */\n\tsort(\n\t\tfn: (\n\t\t\tcart_item_A: ShoppingCartItem<ProductType>,\n\t\t\tcart_item_B: ShoppingCartItem<ProductType>,\n\t\t) => number,\n\t) {\n\t\tthis.items.sort(fn);\n\t\tthis.updateDependentStates();\n\n\t\t// Trigger change\n\t\tthis.emitOnChange();\n\t}\n\n\t/**\n\t * Initiates the checkout process by calling the onCheckout callback function, if provided.\n\t * @throws Error if the onCheckout function is not provided.\n\t */\n\tcheckout() {\n\t\tif (this.onCheckout) {\n\t\t\treturn this.onCheckout(this);\n\t\t}\n\t\tthrow new Error(\n\t\t\t\"Error: Called checkout function without providing a onCheckout function\",\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new instance of the ShoppingCart class.\n\t * @param args The parameters to initialize the shopping cart.\n\t */\n\tconstructor(args: ICartParameters<ProductType>) {\n\t\tconst { items = [], onChange, onCheckout } = args;\n\n\t\tif (onChange && typeof onChange !== \"function\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Type error: onChange must be a function. see the documentation.\",\n\t\t\t);\n\t\t}\n\n\t\tif (onCheckout && typeof onCheckout !== \"function\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Type error: onCheckout must be a function. see the documentation.\",\n\t\t\t);\n\t\t}\n\n\t\tthis.items = [...items];\n\t\tthis.onChange = onChange;\n\t\tthis.onCheckout = onCheckout;\n\t\tthis.updateDependentStates();\n\t}\n}\n","export interface IPersistanceConfig {\n\tstorage: IStorage;\n\tdisabled: boolean;\n\tclear_on_reload: boolean;\n}\n\nexport interface IStorage {\n\tsave: (data: any) => void;\n\tload: () => string | null;\n\tclear: () => void;\n}\n\nexport class LocalStoragePersistence implements IStorage {\n\tprivate key: string;\n\n\tconstructor(key: string) {\n\t\tthis.key = key;\n\t}\n\n\tsave(data: any) {\n\t\tlocalStorage.setItem(this.key, JSON.stringify(data));\n\t}\n\n\tload() {\n\t\tconst data = localStorage.getItem(this.key);\n\t\treturn data ? JSON.parse(data) : null;\n\t}\n\n\tclear() {\n\t\tlocalStorage.removeItem(this.key);\n\t}\n}\n\nexport const defaultPersistanceConfig: IPersistanceConfig = {\n\tdisabled: true,\n\tclear_on_reload: false,\n\tstorage: new LocalStoragePersistence(\"shopping_cart\"),\n};\n","/**\n * Creates a shopping cart context and provides a hook for accessing the shopping cart state.\n * This function returns an object containing the shopping cart context provider component\n * and a hook for consuming the shopping cart context.\n *\n * @typeparam ProductType The type of product items in the shopping cart.\n * @returns An object containing the shopping cart context provider component\n * and a hook for consuming the shopping cart context.\n *\n * @example\n * ```tsx\n * // ./shoppingCart.ts\n * import shoppingCart from \"shoppingcart\";\n *\n * interface YourProductType{\n *  // Definition of you product type\n * }\n *\n * export const {ShoppingCartProvider, useShoppingCart} = shoppingCart<YourProductType>();\n *\n *\n *\n * // <your-file>.tsx\n * import React from 'react';\n * import { ShoppingCartProvider, useShoppingCart } from './shoppingCart';\n *\n * const App = () => {\n *   const { cart } = useShoppingCart();\n *\n *   return (\n *     <div>\n *       <h1>Shopping Cart Example</h1>\n *       {cart ? <p>Cart Items: {cart.item_count}</p> : <p>No items in cart</p>}\n *     </div>\n *   );\n * };\n *\n * export default App;\n * ```\n */\nimport generateShoppingCartContext from \"./ShoppingCartContext\";\nimport generateShoppingCartContextProvider from \"./ShoppingCartProvider\";\nimport generateShoppingCartHook from \"./useShoppingCartContext\";\n/**\n * Export IStorage interface ans LocalStoragePersistance to support customizing persistance-\n * behaviour.\n */\nexport { IStorage, LocalStoragePersistence } from \"./Persistance\";\n\nfunction shoppingCart<ProductType extends object>() {\n\t// Generate the shopping cart context\n\tconst MyShoppingCartContext = generateShoppingCartContext<ProductType>();\n\n\t// Return an object containing the shopping cart context provider component\n\t// and a hook for consuming the shopping cart context\n\treturn {\n\t\t/**\n\t\t * The shopping cart context provider component.\n\t\t * Use this component at the top level of your React application\n\t\t * to provide access to the shopping cart state.\n\t\t */\n\t\tShoppingCartProvider: generateShoppingCartContextProvider(\n\t\t\tMyShoppingCartContext,\n\t\t),\n\t\t/**\n\t\t * A hook for consuming the shopping cart context.\n\t\t * Use this hook to access the shopping cart state within functional components.\n\t\t */\n\t\tuseShoppingCart: generateShoppingCartHook(MyShoppingCartContext),\n\t};\n}\n\nexport default shoppingCart;\n","import { createContext } from \"react\";\nimport ShoppingCart from \"./ShoppingCart\";\n\nexport interface IShoppingCartContext<T extends object> {\n\tcart: ShoppingCart<T> | null;\n\tis_loading: boolean;\n}\n\nconst generateShoppingCartContext = <T extends object>() => {\n\treturn createContext<IShoppingCartContext<T> | null>(null);\n};\n\nexport default generateShoppingCartContext;\n","import React, {\n\tContext,\n\tFC,\n\tPropsWithChildren,\n\tuseEffect,\n\tuseState,\n} from \"react\";\nimport { IShoppingCartContext } from \"./ShoppingCartContext\";\nimport ShoppingCart from \"./ShoppingCart\";\nimport { ShoppingCartItem, isShoppingCartItem } from \"./ShoppingCartItem\";\nimport { IPersistanceConfig, defaultPersistanceConfig } from \"./Persistance\";\n\nexport interface PropType<T extends object> extends PropsWithChildren {\n\t/**\n\t * Optional onCheckout callback. Calling the checkout method from the cart without defining this callback will throw an error.-\n\t * @param cart The cart instance at the time of calling checkout\n\t */\n\tonCheckout?: (cart: ShoppingCart<T>) => void;\n\t/**\n\t * Initial values for the cart items, its has precedence over persisted data when loading\n\t */\n\tinitialItems?: ShoppingCartItem<T>[];\n\t/**\n\t * Persistance configuration\n\t */\n\tpersist?: Partial<IPersistanceConfig> | null;\n}\n\nexport default function generateShoppingCartContextProvider<\n\tProductType extends object,\n>(\n\tContext_: Context<IShoppingCartContext<ProductType> | null>,\n): FC<PropType<ProductType>> {\n\treturn ({\n\t\tchildren,\n\t\tonCheckout,\n\t\tinitialItems,\n\t\tpersist,\n\t}: PropType<ProductType>) => {\n\t\tconst persistance_config = { ...defaultPersistanceConfig, ...persist };\n\n\t\tconst [cart, setCart] = useState<ShoppingCart<ProductType> | null>(null);\n\t\tconst [is_loading, setLoading] = useState(true);\n\n\t\tuseEffect(() => {\n\t\t\tconst updateCart = (\n\t\t\t\tinstance: ShoppingCart<ProductType> | ShoppingCartItem<ProductType>,\n\t\t\t) => {\n\t\t\t\tif (isShoppingCartItem<ProductType>(instance)) {\n\t\t\t\t\tsetCart((cart) => {\n\t\t\t\t\t\tif (!cart) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn cart.clone();\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tsetCart(instance.clone());\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst { disabled, clear_on_reload, storage } = persistance_config;\n\n\t\t\tlet persisted_str: string | null | undefined = undefined;\n\n\t\t\tif (storage && !disabled) {\n\t\t\t\tpersisted_str = storage.load();\n\t\t\t}\n\n\t\t\tconst persisted_data =\n\t\t\t\ttypeof persisted_str === \"string\"\n\t\t\t\t\t? ShoppingCart.parse<ProductType>(persisted_str)\n\t\t\t\t\t: undefined;\n\n\t\t\tconst shoppingCart = new ShoppingCart<ProductType>({\n\t\t\t\tonChange: updateCart,\n\t\t\t\tonCheckout,\n\t\t\t\titems: initialItems ?? persisted_data ?? undefined,\n\t\t\t});\n\t\t\tsetCart(shoppingCart);\n\t\t\tsetLoading(false);\n\n\t\t\treturn () => {\n\t\t\t\t// Clean up\n\t\t\t\tconst { disabled, clear_on_reload, storage } = persistance_config;\n\t\t\t\tif (storage && (disabled || clear_on_reload)) {\n\t\t\t\t\tstorage.clear();\n\t\t\t\t}\n\t\t\t};\n\t\t}, []);\n\n\t\tuseEffect(() => {\n\t\t\tconst { storage, disabled } = persistance_config;\n\t\t\tif (disabled || !storage) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstorage.save(cart);\n\t\t}, [cart]);\n\n\t\tconst value = { cart, is_loading };\n\n\t\treturn <Context_.Provider value={value}>{children}</Context_.Provider>;\n\t};\n}\n","import { Context, useContext } from \"react\";\nimport { IShoppingCartContext } from \"./ShoppingCartContext\";\n\nexport default function generateShoppingCartHook<ProductType extends object>(\n\t_context: Context<IShoppingCartContext<ProductType> | null>,\n) {\n\tconst useShoppingCartContext = () => {\n\t\tconst context = useContext(_context);\n\t\tif (!context) {\n\t\t\tthrow new Error(\n\t\t\t\t\"Error: useShoppingCartContext must be used inside ShoppingCartProvider.\",\n\t\t\t);\n\t\t}\n\t\treturn context;\n\t};\n\n\treturn useShoppingCartContext;\n}\n"],"names":["ShoppingCartItem","onChangeHandler","this","onChangeCallback","isParametersValid","_unit_price","_quantity","_unit_discount","_total_discount","updateTotalPrice","Error","aggregate_price","_aggregate_price","parse","str","onChange","obj","JSON","arg","props","prop","n_value","Number","isNaN","isShoppingCartItemJSON","params","index","id","product","unit_price","quantity","total_discount","unit_discount","valueOf","_index","_id","_product","toJSON","toString","stringify","clone","incrementQuantity","increment_size","decrementQuantity","decrement_size","new_quantity","setTotalDiscount","setIndex","new_index","prev_index","_prev_index","clearPrevIndex","constructor","args","isShoppingCartItem","ShoppingCart","updateDependentStates","hmap","sum","i","items","length","_sub_total","emitOnChange","addNewItem","item","push","removeItemByIndex","splice","removeItemById","moveItem","identifier","removed_item","item_count","sub_total","getCartItem","key","Symbol","iterator","s","trim","replace","item_candidates","split","result","item_candidate","map","onCheckout","fn","addItem","item_already_exists","removeItem","filter","sort","checkout","LocalStoragePersistence","save","data","localStorage","setItem","load","getItem","clear","defaultPersistanceConfig","disabled","clear_on_reload","storage","shoppingCart","MyShoppingCartContext","createContext","ShoppingCartProvider","Context_","children","initialItems","persist","persistance_config","cart","setCart","useState","is_loading","setLoading","useEffect","persisted_str","persisted_data","undefined","instance","value","React","createElement","Provider","useShoppingCart","_context","context","useContext"],"mappings":"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"}